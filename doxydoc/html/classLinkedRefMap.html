<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RayTracer: LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RayTracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classLinkedRefMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Container class representing a vector of objects with keys.  
 <a href="classLinkedRefMap.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linkedmap_8h_source.html">linkedmap.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap__coll__graph.png" border="0" usemap="#aLinkedRefMap_3_01T_00_01Hash_00_01KeyEqual_00_01Map_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 0 -->
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9db9596845180652ad8b36774d6d9b30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> = T *</td></tr>
<tr class="separator:a9db9596845180652ad8b36774d6d9b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#ae57b9ddb3cac6283df8b9747dff2e1da">Vec</a> = std::vector&lt; <a class="el" href="classLinkedRefMap.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &gt;</td></tr>
<tr class="separator:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c1420984bc5d41ef945689343be5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> = typename Vec::iterator</td></tr>
<tr class="separator:aee7c1420984bc5d41ef945689343be5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> = typename Vec::const_iterator</td></tr>
<tr class="separator:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> = typename Vec::reverse_iterator</td></tr>
<tr class="separator:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> = typename Vec::const_reverse_iterator</td></tr>
<tr class="separator:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f6506fe8d15e7f43f61929560a3c377"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a9f6506fe8d15e7f43f61929560a3c377">find</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a9f6506fe8d15e7f43f61929560a3c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3f8cefe5cfd6d46e95889817b92140"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a3d3f8cefe5cfd6d46e95889817b92140">find</a> (const <a class="el" href="classQCString.html">QCString</a> &amp;key) const</td></tr>
<tr class="separator:a3d3f8cefe5cfd6d46e95889817b92140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed765c5f6f6956643f0753c9ea1d714e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#aed765c5f6f6956643f0753c9ea1d714e">find</a> (const char *key) const</td></tr>
<tr class="separator:aed765c5f6f6956643f0753c9ea1d714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e393b31c768a9de5d04455a8596e1a9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a0e393b31c768a9de5d04455a8596e1a9">find</a> (const char *key)</td></tr>
<tr class="memdesc:a0e393b31c768a9de5d04455a8596e1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const wrapper for find() const  <a href="classLinkedRefMap.html#a0e393b31c768a9de5d04455a8596e1a9">More...</a><br /></td></tr>
<tr class="separator:a0e393b31c768a9de5d04455a8596e1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f413af4720b2f575c911b78ee3a70b1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a2f413af4720b2f575c911b78ee3a70b1">find</a> (const <a class="el" href="classQCString.html">QCString</a> &amp;key)</td></tr>
<tr class="separator:a2f413af4720b2f575c911b78ee3a70b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab86c77d6037d5fc0be82fca6e1587"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a6dab86c77d6037d5fc0be82fca6e1587">find</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a6dab86c77d6037d5fc0be82fca6e1587"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const wrapper for find() const  <a href="classLinkedRefMap.html#a6dab86c77d6037d5fc0be82fca6e1587">More...</a><br /></td></tr>
<tr class="separator:a6dab86c77d6037d5fc0be82fca6e1587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273fe87b60116a378346a858e11e4b6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a273fe87b60116a378346a858e11e4b6e">add</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a273fe87b60116a378346a858e11e4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf21f8a88dc994cf1de14246e679579"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#acaf21f8a88dc994cf1de14246e679579">add</a> (const <a class="el" href="classQCString.html">QCString</a> &amp;k, T *obj)</td></tr>
<tr class="separator:acaf21f8a88dc994cf1de14246e679579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821db7bc14f1498938bd5314502f3655"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a821db7bc14f1498938bd5314502f3655">prepend</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a821db7bc14f1498938bd5314502f3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b0589fd4091da2efa1c5ee2da43f73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a98b0589fd4091da2efa1c5ee2da43f73">prepend</a> (const <a class="el" href="classQCString.html">QCString</a> &amp;key, T *obj)</td></tr>
<tr class="separator:a98b0589fd4091da2efa1c5ee2da43f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad70772de2ff561c5883f5a8919c5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a5fad70772de2ff561c5883f5a8919c5d">del</a> (const <a class="el" href="classQCString.html">QCString</a> &amp;key)</td></tr>
<tr class="separator:a5fad70772de2ff561c5883f5a8919c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89581f93afd0740dee45e136d1a54546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a89581f93afd0740dee45e136d1a54546">operator[]</a> (size_t pos)</td></tr>
<tr class="separator:a89581f93afd0740dee45e136d1a54546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d227163284233b8e37f3a265510b49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLinkedRefMap.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a09d227163284233b8e37f3a265510b49">operator[]</a> (size_t pos) const</td></tr>
<tr class="separator:a09d227163284233b8e37f3a265510b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#aee7c1420984bc5d41ef945689343be5c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#ac2f30ce85fd85bfb75bcb56bd10fe9a4">begin</a> ()</td></tr>
<tr class="separator:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d843d470df85d608d8d47b2a56c5e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#aee7c1420984bc5d41ef945689343be5c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a7d843d470df85d608d8d47b2a56c5e80">end</a> ()</td></tr>
<tr class="separator:a7d843d470df85d608d8d47b2a56c5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3307eb17ea829836140639cb52115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a77a3307eb17ea829836140639cb52115">begin</a> () const</td></tr>
<tr class="separator:a77a3307eb17ea829836140639cb52115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a6fed959ab40da898bbebfdb3c8653b2c">end</a> () const</td></tr>
<tr class="separator:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#ac971d2e3cc8e2651f5648b6946b25bd7">rbegin</a> ()</td></tr>
<tr class="separator:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a306a67c71e29179b309647309d6e96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a2a306a67c71e29179b309647309d6e96">rend</a> ()</td></tr>
<tr class="separator:a2a306a67c71e29179b309647309d6e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a2d088d23b0ce73cf2ed3b8cfc2fbe89d">rbegin</a> () const</td></tr>
<tr class="separator:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinkedRefMap.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#ab67fb1418120d42cf91a2a033a6b16ad">rend</a> () const</td></tr>
<tr class="separator:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eea714e29d412612981ac2a8bcab40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#ad4eea714e29d412612981ac2a8bcab40">empty</a> () const</td></tr>
<tr class="separator:ad4eea714e29d412612981ac2a8bcab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a5fe0b41a59bcf683e2ade44911a3fe1d">size</a> () const</td></tr>
<tr class="separator:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67fa2110f306614b020782b88c28c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#ad67fa2110f306614b020782b88c28c83">clear</a> ()</td></tr>
<tr class="separator:ad67fa2110f306614b020782b88c28c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Hash = std::hash&lt;std::string&gt;, class KeyEqual = std::equal_to&lt;std::string&gt;, class Map = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt;<br />
class LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;</div><p >Container class representing a vector of objects with keys. </p>
<p >Objects can be efficiently be looked up given the key. Objects are <em>not</em> owned by the container, the container will only hold references. When adding objects the order of addition is kept, and used while iterating. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae9d600d6dc898d3efd063381f60eaaf7" name="ae9d600d6dc898d3efd063381f60eaaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d600d6dc898d3efd063381f60eaaf7">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::const_iterator =  typename Vec::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d04d68baaeb769cfe0e3cfa9873e40f" name="a5d04d68baaeb769cfe0e3cfa9873e40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d04d68baaeb769cfe0e3cfa9873e40f">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::const_reverse_iterator =  typename Vec::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee7c1420984bc5d41ef945689343be5c" name="aee7c1420984bc5d41ef945689343be5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7c1420984bc5d41ef945689343be5c">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::iterator =  typename Vec::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9db9596845180652ad8b36774d6d9b30" name="a9db9596845180652ad8b36774d6d9b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db9596845180652ad8b36774d6d9b30">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::Ptr =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c63027ad3bccd9ba3a87b2818ecf12a" name="a7c63027ad3bccd9ba3a87b2818ecf12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63027ad3bccd9ba3a87b2818ecf12a">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::reverse_iterator =  typename Vec::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae57b9ddb3cac6283df8b9747dff2e1da" name="ae57b9ddb3cac6283df8b9747dff2e1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57b9ddb3cac6283df8b9747dff2e1da">&#9670;&nbsp;</a></span>Vec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::Vec =  std::vector&lt;<a class="el" href="classLinkedRefMap.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a273fe87b60116a378346a858e11e4b6e" name="a273fe87b60116a378346a858e11e4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273fe87b60116a378346a858e11e4b6e">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a273fe87b60116a378346a858e11e4b6e_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a273fe87b60116a378346a858e11e4b6e_cgraph" alt=""/></div>
<!-- MAP 1 -->
</div>

</div>
</div>
<a id="acaf21f8a88dc994cf1de14246e679579" name="acaf21f8a88dc994cf1de14246e679579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf21f8a88dc994cf1de14246e679579">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCString.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_acaf21f8a88dc994cf1de14246e679579_cgraph.png" border="0" usemap="#aclassLinkedRefMap_acaf21f8a88dc994cf1de14246e679579_cgraph" alt=""/></div>
<!-- MAP 2 -->
</div>

</div>
</div>
<a id="ac2f30ce85fd85bfb75bcb56bd10fe9a4" name="ac2f30ce85fd85bfb75bcb56bd10fe9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f30ce85fd85bfb75bcb56bd10fe9a4">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77a3307eb17ea829836140639cb52115" name="a77a3307eb17ea829836140639cb52115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a3307eb17ea829836140639cb52115">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad67fa2110f306614b020782b88c28c83" name="ad67fa2110f306614b020782b88c28c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67fa2110f306614b020782b88c28c83">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fad70772de2ff561c5883f5a8919c5d" name="a5fad70772de2ff561c5883f5a8919c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fad70772de2ff561c5883f5a8919c5d">&#9670;&nbsp;</a></span>del()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::del </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCString.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Removes an object from the container and deletes it. Returns true if the object was deleted or false it is was not found. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a5fad70772de2ff561c5883f5a8919c5d_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a5fad70772de2ff561c5883f5a8919c5d_cgraph" alt=""/></div>
<!-- MAP 3 -->
</div>

</div>
</div>
<a id="ad4eea714e29d412612981ac2a8bcab40" name="ad4eea714e29d412612981ac2a8bcab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eea714e29d412612981ac2a8bcab40">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d843d470df85d608d8d47b2a56c5e80" name="a7d843d470df85d608d8d47b2a56c5e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d843d470df85d608d8d47b2a56c5e80">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fed959ab40da898bbebfdb3c8653b2c" name="a6fed959ab40da898bbebfdb3c8653b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed959ab40da898bbebfdb3c8653b2c">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e393b31c768a9de5d04455a8596e1a9" name="a0e393b31c768a9de5d04455a8596e1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e393b31c768a9de5d04455a8596e1a9">&#9670;&nbsp;</a></span>find() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non-const wrapper for find() const </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a0e393b31c768a9de5d04455a8596e1a9_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a0e393b31c768a9de5d04455a8596e1a9_cgraph" alt=""/></div>
<!-- MAP 4 -->
</div>

</div>
</div>
<a id="aed765c5f6f6956643f0753c9ea1d714e" name="aed765c5f6f6956643f0753c9ea1d714e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed765c5f6f6956643f0753c9ea1d714e">&#9670;&nbsp;</a></span>find() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_aed765c5f6f6956643f0753c9ea1d714e_cgraph.png" border="0" usemap="#aclassLinkedRefMap_aed765c5f6f6956643f0753c9ea1d714e_cgraph" alt=""/></div>
<!-- MAP 5 -->
</div>

</div>
</div>
<a id="a2f413af4720b2f575c911b78ee3a70b1" name="a2f413af4720b2f575c911b78ee3a70b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f413af4720b2f575c911b78ee3a70b1">&#9670;&nbsp;</a></span>find() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCString.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a2f413af4720b2f575c911b78ee3a70b1_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a2f413af4720b2f575c911b78ee3a70b1_cgraph" alt=""/></div>
<!-- MAP 6 -->
</div>

</div>
</div>
<a id="a3d3f8cefe5cfd6d46e95889817b92140" name="a3d3f8cefe5cfd6d46e95889817b92140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3f8cefe5cfd6d46e95889817b92140">&#9670;&nbsp;</a></span>find() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCString.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a3d3f8cefe5cfd6d46e95889817b92140_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a3d3f8cefe5cfd6d46e95889817b92140_cgraph" alt=""/></div>
<!-- MAP 7 -->
</div>

</div>
</div>
<a id="a6dab86c77d6037d5fc0be82fca6e1587" name="a6dab86c77d6037d5fc0be82fca6e1587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab86c77d6037d5fc0be82fca6e1587">&#9670;&nbsp;</a></span>find() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non-const wrapper for find() const </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a6dab86c77d6037d5fc0be82fca6e1587_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a6dab86c77d6037d5fc0be82fca6e1587_cgraph" alt=""/></div>
<!-- MAP 8 -->
</div>

</div>
</div>
<a id="a9f6506fe8d15e7f43f61929560a3c377" name="a9f6506fe8d15e7f43f61929560a3c377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6506fe8d15e7f43f61929560a3c377">&#9670;&nbsp;</a></span>find() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

</div>
</div>
<a id="a89581f93afd0740dee45e136d1a54546" name="a89581f93afd0740dee45e136d1a54546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89581f93afd0740dee45e136d1a54546">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp; <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09d227163284233b8e37f3a265510b49" name="a09d227163284233b8e37f3a265510b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d227163284233b8e37f3a265510b49">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLinkedRefMap.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp; <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a821db7bc14f1498938bd5314502f3655" name="a821db7bc14f1498938bd5314502f3655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821db7bc14f1498938bd5314502f3655">&#9670;&nbsp;</a></span>prepend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Prepends an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a821db7bc14f1498938bd5314502f3655_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a821db7bc14f1498938bd5314502f3655_cgraph" alt=""/></div>
<!-- MAP 9 -->
</div>

</div>
</div>
<a id="a98b0589fd4091da2efa1c5ee2da43f73" name="a98b0589fd4091da2efa1c5ee2da43f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b0589fd4091da2efa1c5ee2da43f73">&#9670;&nbsp;</a></span>prepend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCString.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classLinkedRefMap_a98b0589fd4091da2efa1c5ee2da43f73_cgraph.png" border="0" usemap="#aclassLinkedRefMap_a98b0589fd4091da2efa1c5ee2da43f73_cgraph" alt=""/></div>
<!-- MAP 10 -->
</div>

</div>
</div>
<a id="ac971d2e3cc8e2651f5648b6946b25bd7" name="ac971d2e3cc8e2651f5648b6946b25bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac971d2e3cc8e2651f5648b6946b25bd7">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d088d23b0ce73cf2ed3b8cfc2fbe89d" name="a2d088d23b0ce73cf2ed3b8cfc2fbe89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d088d23b0ce73cf2ed3b8cfc2fbe89d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a306a67c71e29179b309647309d6e96" name="a2a306a67c71e29179b309647309d6e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a306a67c71e29179b309647309d6e96">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab67fb1418120d42cf91a2a033a6b16ad" name="ab67fb1418120d42cf91a2a033a6b16ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67fb1418120d42cf91a2a033a6b16ad">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinkedRefMap.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fe0b41a59bcf683e2ade44911a3fe1d" name="a5fe0b41a59bcf683e2ade44911a3fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe0b41a59bcf683e2ade44911a3fe1d">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/mnt/c/projects/doxygen/src/<a class="el" href="linkedmap_8h_source.html">linkedmap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
